{"meta":{"title":"Woods","subtitle":"CODE IS POETRY","description":"Java Developer","author":"Woods","url":"https://zhulinn.github.io/blog"},"pages":[{"title":"categories","date":"2018-07-05T04:49:34.000Z","updated":"2018-08-25T04:32:42.807Z","comments":false,"path":"categories/index.html","permalink":"https://zhulinn.github.io/blog/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2018-07-05T04:48:41.000Z","updated":"2018-08-25T04:32:42.839Z","comments":false,"path":"tags/index.html","permalink":"https://zhulinn.github.io/blog/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Spring数据持久化","slug":"spring-persistence","date":"2018-06-13T13:40:49.000Z","updated":"2018-08-25T04:32:42.803Z","comments":true,"path":"/spring-persistence","link":"","permalink":"https://zhulinn.github.io/blog/spring-persistence","excerpt":"Spring数据访问服务对象通过接口访问Repository实现，实现松耦合。Spring JDBC框架提供与平台无关的统一持久化异常。采用模板方法模式，将数据访问过程划分为模板和回调。模板管理过程中固定的部分，而回调处理自定义的数据访问代码。针对不同持久化平台，Spring提供多个可选模板。","text":"Spring数据访问服务对象通过接口访问Repository实现，实现松耦合。Spring JDBC框架提供与平台无关的统一持久化异常。采用模板方法模式，将数据访问过程划分为模板和回调。模板管理过程中固定的部分，而回调处理自定义的数据访问代码。针对不同持久化平台，Spring提供多个可选模板。 JDBC模板JdbcTemplate123456789101112131415161718192021222324252627@Beanpublic JdbcTemplate jdbcTemplate(DataSource dataSource) &#123; return new JdbcTemplate(dataSource);&#125;@Repositorypublic class SpitterRepository &#123; @Autowired private JdbcOperations jdbcOperations; //JdbcOperations是一个接口，定义了JdbcTemplate所实现的操作。 public Spitter findOne(long id) &#123; return jdbcOperations.queryForObject( SELECT_SPITTER_BY_ID, new SpitterRowMapper(), id); &#125; private static final class SpitterRowMapper implements RowMapper&lt;Spitter&gt; &#123; public Spitter mapRow(ResultSet rs, int rowNum) throws SQLException &#123; return new Spitter( rs.getLong(\"id\"), rs.getString(\"username\") ); &#125; &#125;&#125; 对于查询返回的每一行数据，JdbcTemplate将会调用RowMapper的mapRow()方法。RowMapper接口符合函数式接口，只声明一个方法，可以使用Lambda改写。12345678910public Spitter findOne(long id) &#123; return jdbcOperations.queryForObject( SELECT_SPITTER_BY_ID, (rs, rowNum) -&gt; &#123; return new Spitter( rs.getLong(\"id\"), rs.getString(\"username\")); &#125;, id);&#125; 1234567891011public Spitter findOne(long id) &#123; return jdbcOperations.queryForObject( SELECT_SPITTER_BY_ID, this::mapSpitter, id);&#125;private Spitter mapSpitter(ResultSet rs, int row) throws SQLException&#123; return new Spitter( rs.getLong(\"id\"), rs.getString(\"username\") ); &#125; NamedParameterJdbcTemplate通过Map绑定，支持命名参数123456789101112private static final String INSERT_SPITTER = \"insert into Spitter \" + \"(username, password) \" + \"values \" + \"(:username, :password)\";public void addSpitter(Spitter spitter) &#123; Map&lt;String, Object&gt; paramMap = new HashMap&lt;&gt;(); paramMap.put(\"username\",spitter.getUsername()); paramMap.put(\"password\", spitter.getPassword()); jdbcOperations.update(INSERT_SPITTER, paramMap);&#125; 对象-关系映射ORMHibernate配置Session工厂使用Hibernate4.LocalSessionFactoryBean，支持基于XML和基于注解的映射。12345678910@Beanpublic LocalSessionFactoryBean sessionFactory(DataSource dataSource) &#123; LocalSessionFactoryBean sfb = new LocalSessionFactoryBean(); sfb.setDataSource(dataSource)； sfb.setPackagesToScan(new String[] &#123;\"me.zhulin.domain\"&#125;); //扫描@Entity类 Properties props = new Properties(); props.setProperty(\"dialect\", \"org.hibernate.dialect.H2Dialect\"); sfb.setHibernateProperties(props); return sfb;&#125; Repository将SessionFactory装配到Repository，获取Session，不依赖Spring。12345678910111213@Repositorypublic classs Repository&#123; @Autowired SessionFactory sessionFactory; //注入SessionFactory private Session currentsession() &#123; return sessionFactory.getCurrentSession(); //获取当前Session &#125; public Spitter findOne(long id) &#123; retur (Spitter) currentSession().get(Spitter.class, id); &#125; &#125; 给不使用模板的Hibernate Repository添加异常转换功能，声明PersistenceExceptionTranslationPostProcessorbean。它会在所有拥有@Repository注解的类上添加一个通知器（advisor），这样就会捕获任何平台相关的异常并以Spring非检查型数据访问异常的形式重新抛出。1234@Beanpublic BeanPostProcessor persistenceTranslation()&#123; return new PersistenceExceptionTranslationPostProcessor();&#125; JPA配置实体管理器工厂基于JPA的应用程序需要使用EntityManagerFactory的实现类来获取EntityManager实例。JPA定义了两种类型的实体管理器： Application-managed: 程序要负责打开或关闭实体管理器并在事务中对其进行控制。 Container-managed: 实体管理器由Java EE创建和管理。Spring既可承担应用程序角色，也可担当容器角色。 配置Application-managed JPA配置信息位于META-INF/persistence.xml 123456789&lt;persistence&gt; &lt;persistence-unit name=\"spitterPU\"&gt; &lt;class&gt;me.zhulin.domain.Spitter&lt;/class&gt; &lt;class&gt;me.zhulin.domain.Spittle&lt;/class&gt; &lt;properties&gt; &lt;property&gt;&lt;/property&gt; &lt;/properties&gt; &lt;/persistence-unit&gt;&lt;/persistence&gt; 123456@Beanpublic LocalEntityManagerFactoryBean entityManagerFactoryBean()&#123; LocalEntityManagerFactoryBean emfb = new LocalEntityManagerFactoryBean(); emfb.setPersistenceUnitName(\"spitterPU\"); return emfb;&#125; 配置Container-managed JPA配置信息位于Spring应用上下文，persistence.xml没有存在的必要。 1234567891011121314@Beanpublic LocalContainerEntityManagerFactoryBean entityManagerFactoryBean(DataSource dataSource, JpaVendorAdapter JpaVendorAdapter) &#123; LocalContainerEntityManagerFactoryBean emfb = new LocalContainerEntityManagerFactoryBean(); emfb.setDataSource(dataSource); emfb.setJpaVendorAdapter(jpaVendorAdapter); emfb.setPackagesToScan(\"me.zhulin.domain\"); //@Entity return emfb;&#125;@Beanpublic JpaVendorAdapter jpaVendorAdapter() &#123; HibernateJpaVendorAdapter adapter = new HibernateJpaVendorAdapter(); adapter.setDataSource(\"MYSQL\"); adapter.setDatabasePlatform(\"org.hibernate.dialect.MYSQLDialect\");&#125; Repository12345678910@Repository@Transactionalpublic class Repository &#123; @PersistenceUnit private EntityManagerFactory emf; //注入Factory public void addSpitter(Spitter spitter) &#123; emf.createEntityManger().persist(spitter); //创建EntityManger &#125;&#125; 借助@PersistentCotext注解为JpaSpitterRepository注入EntityManager。它没有将真正的EntityManager设置给Repository，而是给了它一个EntityManager的代理。线程安全12345678910@Repository@Transactionalpublic class Repository &#123; @PersistenceContext private EntityManager em; //注入Factory public void addSpitter(Spitter spitter) &#123; em.persist(spitter); //创建EntityManger &#125;&#125; @PersistenceUnit和@PersistenceContext并不是Spring的注解，它们是由JPA规范提供的。为了让Spring理解这些注解，要声明PersistenceAnnotationBeanPostProcessor的bean，或者使用&lt;context:annotation-config&gt;或&lt;context:componentscan&gt;Spring统一数据访问异常。1234@Beanpublic BeanPostProcessor persistenceTranslation()&#123; return new PersistenceExceptionTranslationPostProcessor();&#125; Spring Data实现自动化JPA Repository启用Spring Data创建Repository接口的实现，&lt;jpa:repositories base-package=&quot;me.zhulin.db&quot;/&gt; or @EnableJpaRepositories(basePackages=&quot;me.zhulin.db&quot;)扫描扩展自Spring Data JPA Repository接口的所有接口，自动生成实现类。&lt;Spitter, Long&gt;对JpaRepository参数化，持久化对象为Spitter，ID类型为Long123public interface SpitterRepository extends JpaRepository&lt;Spitter, Long&gt; &#123; List&lt;Spitter&gt; readByFirstnameOrLastnameAllIgnoresCaseOrderByLastnameAscFirstnameDesc(String first, String last);&#125; 定义查询方法DSLRepository方法由 动词 + Subject + By + 断言 组成。动词：get/read/find, countSubject可选，以Distinct开头，确保不重复. @Query12@Query(\"select s from Spitter s where s.email like '%gmail.com'\")List&lt;Spitter&gt; findAllGmailSpitters(); 混合自定义功能Spring Data JPA为Repository接口生成实现的时候，它还会查找名字与接口相同，并且添加了Impl后缀的一个类。如果这个类存在的话，Spring Data JPA将会把它的方法与Spring Data JPA所生成的方法合并在一起。123public intface SpitterSweeper&#123; int eliteSweep();&#125; 1234567891011public class SpitterRepositoryImpl implements SpitterSweeper &#123; @PersistenceContext private EntityManager em; public int eliteSweep()&#123; String sql = \"update Spitter spitter set spitter.status = 'Eliite' \" + \"where spitter.status = 'Newbie'\"; return em.createQuery(sql).excuteUpdate(); &#125;&#125; 123public interface SpitterRepository extends JpaRepository&lt;Spitter, Long&gt;, SpitterSweeper&#123; &#125; NoSQLMongoDB 配置MongoDB123456789101112131415@Configuration@EnableMongoRepositories(basePackages=\"orders.db\")public class MongoConfig &#123; @Bean public MongoFactoryBean mongo()&#123; MongoFactoryBean mongo = new MongoFactoryBean(); //不必处理UnknownHostException mongo.setHost(\"localhost\"); return mongo; &#125; @Bean public MongoOperations mongoTemplate(Mongo mongo) &#123; return new mongoTemplate(mongo,\"OrdersDB\"); &#125;&#125; or 12345678910111213@Configuration@EnableMongoRepositories(\"orders.db\")public class MongoConfig extends AbstractMongoConfiguration &#123; @Override protected String getDatabaseName()&#123; return \"OrdersDB\"; &#125; @Override protected Mongo() throws Exception &#123; return new MongoClient(\"server\", 27017); &#125;&#125; 添加MongoDB持久化注解Spring Data MongoDB注解：@Document、@Id、@Field 使用MongoTemplate访问MongoDB 12345@AutowiredMongoOperations mongo;List&lt;Order&gt; orders = mongo.find(Query.query(Criteria.where(\"customer\").is(\"Chuck Wagon\") .and(\"type\").is(\"WEB\")), Order.class); 编写Repository 1234piblic interface OrderRepository extends MongoRepository&lt;Order, String&gt; &#123; @Query(\"&#123;'customer': 'Chuck Wagon', 'type': ?0&#125;\") //?0 第0个参数相等 List&lt;Order&gt; findOrders(String type);&#125; Redis 配置工厂 1234567public RedisConnectionFactory redisCF() &#123; JedisConnectionFactory cf = new JedisConnectionFactory(); //cf.setHostName(\"redis-server\"); //cf.setPort(7379); // cf.setPassword(\"psd\") return cf;&#125; 使用模板 1234RedisConnectionFactory cf = new JedisConnectionFactory();RedisTemplate&lt;String, Product&gt; redis = new RedisTemplate&lt;String, Product&gt;();// StringRedisTemplate redis = new StringRedisTemplate(cf);redis.setConnectionFactory(cf); 操作 123redis.opsForValue().set(product.getSku(), product);redis.opsForList().rightPush(\"cart\", product);redis.opsForList().range(\"cart\", 1,3); 缓存缓存是一种面向切面的行为。 启用缓存,@EnableCaching or &lt;cache:annotation-driven /&gt; 配置缓存管理器123456789101112131415@Configuration@EnableCachingpublic class CachingConfig &#123; @Bean public EhCacheCacheManager cacheManager(CacheManager cm) &#123; return new EhCacheCacheManager(cm); //Spring 的EhCacheCacheManager &#125; @Bean public EhCacheManagerFactoryBean ehcache()&#123; EhCacheManagerFactoryBean ehCacheFactoryBean = new EhCacheManagerFactoryBean(); ehCacheFactoryBean.setConfigLocation(new ClassPathResource(\"me/zhulin/ehcache.xml\")); return ehCacheFactoryBean; //EhCache 的CacheManager &#125;&#125; Redis123456789101112131415161718192021@Configuration@EnableCachingpublic class CachingConfig &#123; @Bean public CacheManager cacheManager(RedisTemplate redisTemplate) &#123; return new RedisCacheManager(redisTemplate); @Bean public JedisConnectionFactory redisConnectionFactory()&#123; JedisConnectionFactory jedisConnectionFactory = new JedisConnectionFactory.afterPropertiesSet(); return jedisConnectionFactory; &#125; @Bean public RedisTemplate&lt;String, String&gt; redisTemplate(RedisConnectionFactory redisCF)&#123; RedisTemplate&lt;String, String&gt; redisTemplate = new RedisTemplate&lt;&gt;(); redisTemplate.setConnectionFactory(redisCF); redisTemplate.afterPropertiesSet(); return redisTemplate; &#125;&#125; 缓存注解 @Cacheable：调用前检查缓存 @CachePut： 调用前不检查缓存 @CacheEvict：清除缓存 @Caching @Cacheable和@CachePut有一些属性是共有的，默认的缓存key要基于方法的参数来确定。 value: 缓存名称 condition：禁用缓存 key： 缓存key unless：阻止写入缓存","categories":[{"name":"Java Web","slug":"Java-Web","permalink":"https://zhulinn.github.io/blog/categories/Java-Web/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"https://zhulinn.github.io/blog/tags/Spring/"}]},{"title":"Spring Security","slug":"spring-security","date":"2018-06-12T14:36:17.000Z","updated":"2018-08-25T04:32:42.800Z","comments":true,"path":"/spring-security","link":"","permalink":"https://zhulinn.github.io/blog/spring-security","excerpt":"Spring Security原理DelegatingFilterProxy是一个特殊的Servlet Filter，将工作委托给javax.servlet.Filter实现类。","text":"Spring Security原理DelegatingFilterProxy是一个特殊的Servlet Filter，将工作委托给javax.servlet.Filter实现类。 配置DelegatingFilterProxy123public class SecurityWebInitializer extends AbstractSecurityWebApplicationInitializer &#123;&#125; 1234&lt;filter&gt; &lt;filter-name&gt;springSecurityFilterChain&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.DelegatingFilterProxy&lt;/filter-class&gt;&lt;/filter&gt; 配置Web安全性实现WebSecurityConfigurer或拓展WebSecurityConfigurerAdapter1234567891011121314@Configuration@EnableWebMvcSecurity //启用Web安全功能// @EnableWebSecuritypublic class SecurityConfig extends WebSecurityConfigurerAdapter &#123; @Override protecte void configure(WebSecurity webSecurity) &#123;&#125;; //配置Filter链 @Override protecte void configure(HttpSecurity httpSecurity) &#123;&#125;; //配置如何拦截 @Override //配置用户存储 protecte void configure(AuthenticationManagerBuilder authenticationManagerBuilder) &#123;&#125;; &#125; @EnableWebMvcSecurity配置了一个Spring MVC参数解析解析器(argument resolver)，处理器方法能够通过带有@AuthenticationPrincipal注解的参数获得认证用户的principal（或username）。它同时还配置了一个bean，自动添加一个隐藏的跨站请求伪造（cross-site request forgery，CSRF）token输入域。 用户存储基于内存1234567@Overrideprotected void configure(AuthenticationManagerBuilder auth) throws Exception &#123; auth .inMemoryAuthentication() .withUser(\"user\").password(\"password\").roles(\"USER\").and() .withUser(\"admin\").password(\"password\").roles(\"USER\",\"ADMIN\");&#125; roles()方法是authorities()方法的简写形式。roles()方法所给定的值都会添加一个“ROLE_”前缀，并将其作为权限授予给用户。 基于数据库表12345678910111213@AutowiredDataSource dataSource;@Overrideprotected void configure(AuthenticationManagerBuilder auth) throws Exception &#123; auth .jdbcAuthentication() .dataSource(dataSource) .usersByUsernameQuery(\"select username, password, enabled from Spitter where username=?\") .authoritiesByUsernameQuery(\"select username, role from Spitter where username=?\") .passwordEncoder(new StandardPasswordEncoder(\"example\")); // BCryptPasswordEncoder、NoOpPasswordEncoder&#125; 自定义UserDetailsService提供一个自定义的UserDetailsService接口实现12345678@AutowiredSpitterRepository spitterRepository;@Overrideprotected void configure(AuthenticationManagerBuilder auth) throws Exception &#123; auth .userDetailsService(new SpitterUserService(spitterRepository));&#125; 123456789101112131415161718public class SpitterUserservice implements UesrDetailsService &#123; private final SpitterRepository spitterRepository; // 注入SpitterRepository public SpitterUserService(SpitterRepository spitterRepository) &#123; this.spitterRepository = spitterRepository; &#125; @Override public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException &#123; if(spitter != null ) &#123; List&lt;GrantedAuthority&gt; authorities = new ArrayList&lt;&gt;(); authorities.add(new SimpleGrantedAuthority(\"ROLE_SPITTER\")); return new User(spitter.getUserName(), spitter.getPassword(), authorities); &#125; &#125;&#125; 拦截请求由上到下，优先匹配原则。123456789101112131415@Overrideprotected void configure(HttpSecurity http) throws Exception &#123; http .authorizeRequests() .antMatchers(\"/spitters/me\").hasAuthority(\"ROLE_SPITTER\") .antMatchers(HttpMethod.POST, \"/spitters\").hasRole(\"SPITTER\") .anyRequest().permitAll(); .and() .requiresChannel() .antMatchers(\"/spitter/form\").requiresSecure() //HTTPS .and() .csrf() .disable(); //禁用CSRF防护&#125; 跨站请求CSRF防护Spring Security通过一个同步token的方式来实现CSRF防护的功能。所有的表单必须在一个_csrf域中提交token，而且这个token必须要与服务器端计算并存储的token一致，这样的话当表单提交的时候，才能进行匹配。&lt;sf:form&gt;、th:action标签会自动为我们添加隐藏的CSRF token标签。 认证用户123456@Overrideprotected void configure(HttpSecurity http) throws Exception &#123; http .formLogin() .loginPage(\"/login\")&#125; HTTP Basic认证HTTP Basic实际上就是将我们的用户名和密码连接起来user:password，然后使用base64进行加密，将加密后的密文Basic dXNlcjpwYXNzd29yZA0K放在HTTP的header中进行验证。Authorization: Basic dXNlcjpwYXNzd29yZA0K123456@Overrideprotected void configure(HttpSecurity http) throws Exception &#123; http .httpBasic() .realmName(\"name\")&#125; Remember-me通过在cookie中存储一个token完成，包含用户名、密码、过期时间和一个私钥。1234567@Overrideprotected void configure(HttpSecurity http) throws Exception &#123; http .rememberMe() .tokenValiditySeconds() .key(\"key\")&#125; 页面登录表单中，增加name=&quot;remember-me&quot;复选框。 退出用户退出应用，remember-me token被清除，默认重定向”/login?logout”1234567@Overrideprotected void configure(HttpSecurity http) throws Exception &#123; http .logout() .logoutUrl(\"/signout\") .logoutSuccessUrl(\"/\")&#125; 视图保护 Spring Security的JSP标签库 &lt;security:accesscontrollist&gt; &lt;security:authentication property=&quot;principal.username&quot;&gt; 获取认证对象信息 &lt;security:authorize access=&quot;hasRole(&#39;ROLE_SPITTER&#39;)&quot; url=&quot;/admin&quot;&gt; 方法安全性注解保护方法启用基于注解的方法安全性12345@Configuration@EnableGlobalMethodSecurity(securedEnabled=true)public class MethodSecurityConfig extends GlobalMethodSecurityConfiguration &#123;&#125; @Secured({“ROLE_SPITTER”,”ROLE_ADMIN”}) @RolesAllowed({“ROLE_SPITTER”,”ROLE_ADMIN”}) SpEL表达式启用基于表达式的方法安全性12345@Configuration@EnableGlobalMethodSecurity(prePostEnabled=true)public class MethodSecurityConfig extends GlobalMethodSecurityConfiguration &#123;&#125; @PreAuthorize 12345@PreAuthorize(\"(hasRole('ROLE_SPITTER') and #spittle.text.length() &lt;= 140)\" \"or hasRole('ROLE_PREMIUM')\")public void addSpittle(Spittle spittle)&#123;&#125; @PostAuthorize 1234@PostAuthorize(\"returnObject.spitter.username == princical.username\")public Spittle getSpittleById(long id) &#123;&#125; @PostFilter 1234@PostFilter(\"hasRole('ROLE_ADMIN') || filterObject.spitter.username == principal.name\")public List&lt;Spittle&gt; getOffensiveSpittles() &#123;&#125; @PreFilter 1234@PreFilter(\"hasRole('ROLE_ADMIN') || targetObject.spitter.username == principal.name\")public void deleteSpittles(List&lt;Spittle&gt; spittles) &#123;&#125; 自定义PermissionEvaluator 实现PermissionEvaluator接口实例 注册1234567 @Override protected MethodSecurityExpressionHandler createExpressionHandler()&#123; DefaultMethodSecurityExpressionHandler expressionHandler = new DefaultMethodSecurityExpressionHandler(); expressionHandler.setPermissionEvaluator(new SpittlePermissionEvaluator()); return expressionHandler; &#125;`","categories":[{"name":"Java Web","slug":"Java-Web","permalink":"https://zhulinn.github.io/blog/categories/Java-Web/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"https://zhulinn.github.io/blog/tags/Spring/"}]},{"title":"Spring MVC","slug":"Spring-MVC","date":"2018-06-09T15:53:50.000Z","updated":"2018-08-25T04:32:42.796Z","comments":true,"path":"/Spring-MVC","link":"","permalink":"https://zhulinn.github.io/blog/Spring-MVC","excerpt":"Spring MVC基础知识","text":"Spring MVC基础知识 搭建Spring MVC配置DispatcherServlet Servlet容器 -&gt; extends AbstractAnnotationConfigDispatcherServletInitializerServletContainerInitializer接口 -&gt;SpringServletContainerInitializer实现 -&gt;WebApplicationInitializer接口 -&gt; AbstractAnnotationConfigDispatcherServletInitializer实现 1234567891011121314151617public class WebAppInitializer extends AbstractAnnotationConfigDispatcherServletInitializer &#123; @Override protected String[] getServletMappings()｛ return new String[] &#123; \"/\" &#125;; // 将DispatcherServlet映射到\"/\" ｝ @Override protected Class&lt;?&gt;[] getRootConfigClasses() &#123; //配置ContextLoaderListener应用上下文的其他非web组件bean return new Class&lt;?&gt;[] &#123; RootConfig.class &#125;; &#125; @Override protected Class&lt;?&gt;[] getServletConfigClasses() &#123; //配置DispatcherServlet应用上下文包含web组件的bean，控制器、视图解析器等 return new Class&lt;?&gt;[] &#123; WebConfig.class &#125;; //配置类 &#125;&#125; 配置web.xml web.xml12345678910111213141516171819202122232425&lt;servlet&gt; &lt;servlet-name&gt;dispatcher&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;/WEB-INF/dispatcher-context.xml&lt;/param-value&gt; &lt;/init-param&gt;&lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;dispatcher&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;/WEB-INF/root-context.xml&lt;/param-value&gt; &lt;/context-param&gt; &lt;listener&gt; &lt;listener-class&gt; org.springframework.web.context.ContextLoaderListener &lt;/listener-class&gt; &lt;/listener&gt; dispatcher-context.xml12345678910&lt;context:component-scan base-package=\"me.zhulin.controller\"&gt;&lt;/context:component-scan&gt;&lt;bean class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\"&gt; &lt;property name=\"prefix\"&gt; &lt;value&gt;/&lt;/value&gt; &lt;/property&gt; &lt;property name=\"suffix\"&gt; &lt;value&gt;.jsp&lt;/value&gt; &lt;/property&gt;&lt;/bean&gt; ContextLoaderListener和DispatcherServlet各自都会加载一个Spring应用上下文。上下文参数contextConfigLocation指定了一个XML文件的地址，这个文件定义了根应用上下文，它会被ContextLoaderListener加载。若DispatcherServlet未指定XML文件地址,DispatcherServlet会根据Servlet的名字找到一个文件，并基于该文件加载应用上下文。例如，DispatcherServlet会从/WEBINF/dispatcher-context.xml文件中加载bean。 启动Spring MVC 使用mvc:annotationdriven启用注解驱动的Spring MVC。 配置 Spring MVC WebConfig.class12345678910111213141516171819@Configuration@EnableWebMvc@ComponentScan(\"me.zhulin.controller\")public class WebConfig extends WebMvcConfigurerAdapter &#123; @Bean public ViewResolver viewResolver() &#123; InternalResourceViewResolver resolver = new InternalResourceViewResolver(); resolver.setPrefix(\"/WEB-INF/views/\"); resolver.setSuffix(\".jsp\"); resolver.setExposeContextBeansAsAttributes(true); return resolver; &#125; @Override public void configureDefaultServletHandling(DefaultServletHandlerConfigurer configurer) &#123; //配置静态资源处理 configurer.enable(); //转交默认Servlet,而非DispatcherServlet &#125;&#125; RootConfig.class12345@Configuration@ComponentScan(\"me.zhulin\")public class RootConfig &#123;&#125; 控制器1234567891011121314151617181920@Controller@RequestMapping(\"/spittles\")public class SpittleController &#123; private SpittleRepository spittleRepository; @Autowired public SpittleController(SpittleRepository spittleRepository) &#123; this.spittleRepository = spittleRepository; &#125; @RequestMapping(method=GET) public String spittles(Model model) &#123; model.addAttribute(spittleRepository.findSpittles(Long.MAX_VALUE, 20)); //key: spittleList reutrn \"spittles\"; // /WEB-INF/views/spittles.jsp &#125; //当controller没有显式设定模型，也没有返回视图名，只是返回对象或集合时， //处理器会将值放入模型，视图名根据请求路径推断&#125; 测试控制器12345678910111213141516171819202122232425public class SpittleControllerTest &#123; @Test public void testSpittlesPage() throws Exception &#123; List&lt;Spittle&gt; expectedSpittles = createSpittleList(20); //新建20个，方法略 SpittleRepository mockRepository = mock(SpittleRepository.class); //Mock Repository when(mockRepository.findSpittles(Long.MAX_VALUE,20)) // Mock 方法 .thenReturn(expectedSpittles); SpittleController controller = new SpittleController(mockRepository); //MockMvcBuilders.standaloneSetup() MockMvc mockMvc = standaloneSetup(controller) .setSingleView(new InternalResourceVIew(\"/WEB-INF/views/spittles.jsp\")) // 不再解析视图名 可省略 .build(); mockMvc.perform(get(\"/spittles\")) .andExpect(view().name(\"spittles\")) .andExpect(model().attributeExists(\"spittleList\")) .andExpect(model().attribute(\"spittleList\", hasItems(expectedSpittles.toArray()))); // .andExpect(redirectedUrl(\"/spitter/jbauer\")) &#125;&#125; Spring MVC高级技术 multipart数据配置multipart解析器MultipartResolver接口的实现解析multipart请求数据。 CommonsMultipartResolver StandardServletMultipartResolver(Servlet3.0，推荐)1234@Beanpublic MultipartResolver multipartResolver() throws IOException &#123; return new StandardServletMultipartResolver();&#125; 通过重载AbstractAnnotationConfigDispatcherServletInitializer的customizeRegistration()配置multipart具体细节：1234567@Overrideprotected void customizeRegistration(Dynamic registration) &#123; registration.setMultipartConfig( new MultipartConfigElement(\"/tmp/spittr/uploads\", 2097152, 4194304, 0)); //绝对路径，文件大小，请求大小，全部写入磁盘&#125; 1234567891011121314&lt;servlet&gt; &lt;servlet-name&gt;dispatcher&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;multipart-config&gt; &lt;location&gt;/tmp/spittr/uploads&lt;/location&gt; &lt;max-file-size&gt;2097152&lt;/max-file-size&gt; &lt;max-request-size&gt;4194304&lt;/max-request-size&gt; &lt;/multipart-config&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;/WEB-INF/dispatcher-context.xml&lt;/param-value&gt; &lt;/init-param&gt;&lt;/servlet&gt; 处理multipart请求控制器方法参数添加@RequestPart @RequestPart(“profilePicture”) byte[] profilePicture @RequestPart(“profilePicture”) MultipartFile profilePicture (推荐) @RequestPart(“profilePicture”) Part profilePicture (无需配置MultipartResolver) 处理异常异常映射HTTP状态码1234@ResponseStatus(value=HttpStatus.NOT_FOUND, reason=\"Spittle Not Found\")public class SpittleNotFoundException extends RuntimeException &#123;&#125; @ExceptionHandler方法控制器添加@ExceptionHandler方法，处理同一个控制器类中所有指定异常。1234@ExceptionHandler(DuplicateSpittleException.class)public String handleDuplicateSpittle()&#123; return \"error/duplicate\";&#125; 通知任意带有@ControllerAdvice注解的类(@Component)，包含： @ExceptionHandler注解标注的方法； @InitBinder注解标注的方法； @ModelAttribute注解标注的方法(方法级：Model添加属性；参数级：绑定Object属性)。以上所述的这些方法会运用到整个应用程序所有控制器中带有@RequestMapping注解的方法上。1234567@ControllerAdvicepublic class AppExceptionHandler &#123; @ExceptionHandler(DuplicateSpittleException.class) public String handleDuplicateSpittle()&#123; return \"error/duplicate\"; &#125;&#125; 1234567891011public class MyCustomEnumConverter implements Converter&lt;String, SortEnum&gt; &#123; @Override public SortEnum convert(String source) &#123; try &#123; return SortEnum.valueOf(source); &#125; catch(Exception e) &#123; return null; // or SortEnum.asc &#125; &#125;&#125; 1234@InitBinderpublic void initBinder(WebDataBinder dataBinder) &#123; dataBinder.registerCustomEditor(Currency.class, new CurrencyEnumConverter());&#125; 重定向请求传递数据URL模板123model.addAttribute(\"userName\", spitter.getUserName());model.addAttribute(\"spitterId\", spitter.getId());return \"redirect:/spitter/&#123;userName&#125;\"; userName作为占位符填充。Model中原始类型数据可添加到URL作为查询参数。spitterId没有匹配占位符，自动以查询参数形式添加到URL。 flash属性flash属性保存在会话中，然后再放到模型中，因此能够在重定向的过程中存活。通过Model子接口RedirectAttributes#addFlashAttribute()，设置flash属性。12345678@RequestMapping(value=\"/register\",method=POST)public String processRegistration(Spitter spitter, RedirectAttributes model) &#123; spitterRepository.save(spitter); model.addAttribute(\"userName\", spitter.getUserName()); model.addFlashAttribute(\"spitter\",spitter); return \"redirect:/spitter/&#123;userName&#125;\";&#125; Spring Boot The @SpringBootApplication annotation is equivalent to using @Configuration, @EnableAutoConfiguration and @ComponentScan with their default attributes. The relationship between the Controller and the View","categories":[{"name":"Java Web","slug":"Java-Web","permalink":"https://zhulinn.github.io/blog/categories/Java-Web/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"https://zhulinn.github.io/blog/tags/Spring/"}]},{"title":"Amazon EC2 + Shadowsocks免费搭建VPN服务器，实现个人科学上网","slug":"AWS-EC2-Shadowsocks-VPN","date":"2018-05-19T02:58:12.000Z","updated":"2018-08-25T04:32:42.792Z","comments":true,"path":"/AWS-EC2-Shadowsocks-VPN","link":"","permalink":"https://zhulinn.github.io/blog/AWS-EC2-Shadowsocks-VPN","excerpt":"前言暑期回国，给自用的Sumsung S8恢复了出厂。万万没想到的是，由于手机是美版的，需要谷歌账号验证激活，否则无法进入系统。 卒。 最后好不容易给电脑用上VPNGate，共享Wifi给手机翻墙，成功激活手机。途中尝试了一些曾经用过的免费VPN软件，如赛风、XX-Net，效果都不尽人意。之前有用过Amazon AWS，里面涵盖一年免费的服务器套餐，于是准备利用其中的Amazon EC2,自己搭建个VPN服务器配合shadowsocks,搭个自用的梯子。","text":"前言暑期回国，给自用的Sumsung S8恢复了出厂。万万没想到的是，由于手机是美版的，需要谷歌账号验证激活，否则无法进入系统。 卒。 最后好不容易给电脑用上VPNGate，共享Wifi给手机翻墙，成功激活手机。途中尝试了一些曾经用过的免费VPN软件，如赛风、XX-Net，效果都不尽人意。之前有用过Amazon AWS，里面涵盖一年免费的服务器套餐，于是准备利用其中的Amazon EC2,自己搭建个VPN服务器配合shadowsocks,搭个自用的梯子。 Amazon AWS EC2Amazon对新用户提供一些一年免费的服务。我们需要用的就是AWS EC2(虚拟服务器)。需要注意的是： EC2每个月有750个小时的免费使用时间。这个时长是所有实例运行时间的总长，如果你只有一个实例，完全可以满足24小时的全天候运行。 每个月上传/下载各15GB免费流量。VPN服务器主要使用的是下载流量。15GB足够满足个人使用。 还有一些免费额度，一般不会超额。建议大家开启超额预警，同时在账单页面关注自己的使用情况。 流程这里我们使用Amazon EC2作为海外服务器，通过安装shadowsocks服务器版，架设VPN服务器。在手机、电脑上安装shadowsocks客户端，科学上网。 Amazon注册Amazon注册流程在这里就不啰嗦了，网上的教程也很多。注册过程需要绑定一张信用卡，如果你的使用量都涵盖在免费套餐内，是不会随意扣费的，这点放心。不过当用户使用量超额时，会自动扣费，所以需要时刻关注自己的套餐使用量. EC2服务器创建1. 登陆Amazon AWS，Products标签页下选择Amazon EC2。 2. EC2页面上，创建新的实例。 注意要看页面右上角，显示着服务器实例的所在区域。如图， 我的是Singapore，即我的VPN服务器架设在Singapore节点。服务器将会转发你的上网数据，理论上节点离你越近，你的网速越快。这里可以用CloudPing.info对Amazon提供的各个节点进行测速，选择理想的节点。 特别注意对于新用户, Amazon只提供Ohio，Oregon，Virginia三个节点。因此若使用其他节点，会出现创建失败的情况。 From StackOverflow解决方案如邮件所说，向 aws-verification@amazon.com 发邮件申请既可。 3. 选择Ubuntu Server，实例类型我们选择支持免费套餐的micro类型。 4. 保持默认配置不变，我们直接跳到第6步，配置安全组。为了方便，我们可以直接添加如下规则。 5. 配置完成后，创建新实例。这时会让你选择服务器的密钥对，我们选择创建新的密钥对。名字随意。创建后，下载并保持钥匙对，用来连接服务器。务必保存好。 6. 创建完成后，服务器已经开始运行。我们可以进入EC2面板，查看正在运行的实例。我们需要服务器的公网IP地址，用来连接服务器。 至此，Amazon EC2服务器算是创建好了，下一步我们将在服务器上安装shadowsocks服务器版。参考网上的教程总结如下。 shadowsocks服务器版安装1. 连接服务器实例因为用的是Windows，我就说下Windows如何连接Amazon EC2服务器。OS X请参考相关教程。Windows下，需要用到Xshell5软件进行连接。安装完成后，我们首先添加密钥对。就是刚刚创建实例时，我们下载的密钥对。进入用户密钥管理员，导入我们之前下载的.pem文件。 之后创建与服务器的会话。 填写服务器的公网IP地址。 之后配置认证信息。选择Public Key方法，用户名填写为ubuntu（否则报错）。用户密钥栏选择我们刚刚导入的密钥对即可。 最后点击确定后，在会话窗口选择创建的会话进行连接。首次连接，会提示警告，选择接受并保存即可。成功连接后如图。 2. 安装shadowsocks123456789# 获取root权限sudo -s# 更新apt-getapt-get update# 安装python包管理工具apt-get install python-setuptoolsapt-get install python-pip# 安装shadowsockspip install shadowsocks 安装pip后，可能会提示更新pip，不需要更新，否则之后安装Shadowsocks会报错。 3. 配置shadowsocks安装完成后，创建配置文件。1vim /etc/shadowsocks/ss.json 按i进入输入模式，复制以下内容。1234567891011&#123; \"server\":\"0.0.0.0\", \"server_port\":443, //ss连接服务器的端口 \"local_address\":\"127.0.0.1\", \"local_port\":1080, \"password\":\"abcd1234\", // 设置ss连接时的密码 \"timeout\":300, \"method\":\"aes-256-cfb\", \"fast_open\":false, \"workers\": 1&#125; 4. 启动shadowsocks启动：sudo /usr/local/bin/ssserver -c /etc/shadowsocks/ss.json -d start停止：sudo /usr/local/bin/ssserver -c /etc/shadowsocks/ss.json -d stop重启：sudo /usr/local/bin/ssserver -c /etc/shadowsocks/ss.json -d restart 设置自启动。1sudo vi /etc/rc.local 在rc.local文件末尾添加以下代码： sudo /usr/local/bin/ssserver -c /etc/shadowsocks/ss.json -d start 至此Amazon EC2 + Shadowsocks 的VPN服务器已经假设完成。本地设备通过shadowsocks客户端连接VPN服务器，即可实现翻墙。添加服务器，地址即为Amazon EC2的公网IP，端口为配置文件中设置的443，密码为abcd1234。 shadowsocks客户端可从Github上下载。shadowsocks-安卓版shadowsocks-Windows版","categories":[{"name":"日常","slug":"日常","permalink":"https://zhulinn.github.io/blog/categories/日常/"}],"tags":[{"name":"翻墙","slug":"翻墙","permalink":"https://zhulinn.github.io/blog/tags/翻墙/"}]},{"title":"Network基础知识","slug":"Network-notes","date":"2018-04-19T20:16:02.000Z","updated":"2018-08-25T04:32:42.789Z","comments":true,"path":"/Network-notes","link":"","permalink":"https://zhulinn.github.io/blog/Network-notes","excerpt":"Refefence:Interview-Notebook 主机之间的通信方式 客户-服务器（C/S） 传输控制协议 TCP（Transmission Control Protocol） 是面向连接的，提供可靠交付，有流量控制，拥塞控制，提供全双工通信，面向字节流（把应用层传下来的报文看成字节流，把字节流组织成大小不等的数据块）客户是服务的请求方，服务器是服务的提供方。 对等（P2P） 不区分客户和服务器。","text":"Refefence:Interview-Notebook 主机之间的通信方式 客户-服务器（C/S） 传输控制协议 TCP（Transmission Control Protocol） 是面向连接的，提供可靠交付，有流量控制，拥塞控制，提供全双工通信，面向字节流（把应用层传下来的报文看成字节流，把字节流组织成大小不等的数据块）客户是服务的请求方，服务器是服务的提供方。 对等（P2P） 不区分客户和服务器。 五层体系结构 应用层：FTP/SMTP，报文 运输层：TCP/UDP，报文段/数据报 网络层：IP，分组 数据链数层：帧， 物理层 UDP 和 TCP 的特点 用户数据包协议 UDP（User Datagram Protocol）是无连接的，尽最大可能交付，没有拥塞控制，面向报文（对于应用程序传下来的报文不合并也不拆分，只是添加 UDP 首部）。 传输控制协议 TCP（Transmission Control Protocol） 是面向连接的，提供可靠交付，有流量控制，拥塞控制，提供全双工通信，面向字节流（把应用层传下来的报文看成字节流，把字节流组织成大小不等的数据块） TCP三次握手 TCP四次挥手 TIME_WAIT 确保最后一个确认报文段能够到达。如果 B 没收到 A 发送来的确认报文段，那么就会重新发送连接释放请求报文段，A 等待一段时间就是为了处理这种情况的发生。 可能存在“已失效的连接请求报文段”，为了防止这种报文段出现在本次连接之外，需要等待一段时间。 HTTP请求页面 三次握手建立连接。 生成80端口的TCP SYN报文段(套接字socket)，发送给HTTP服务器 HTTP返回TCP SYNACK 建立连接后，发送HTPP GET报文 HTTP服务器从TCP套接字读取HTTP GET报文，生成HTTP响应报文，将Web页面内容放入报文主题，返回 收到HTTP响应报文，提取Web页面内容，渲染显示 请求与响应报文 请求报文 响应报文 HTTP 状态码服务器返回的 响应报文 中第一行为状态行，包含了状态码以及原因短语，用来告知客户端请求的结果。 状态码 类别 原因短语 1XX Informational（信息性状态码） 接收的请求正在处理 2XX Success（成功状态码） 请求正常处理完毕 3XX Redirection（重定向状态码） 需要进行附加操作以完成请求 4XX Client Error（客户端错误状态码） 服务器无法处理请求 5XX Server Error（服务器错误状态码） 服务器处理请求出错","categories":[{"name":"Network","slug":"Network","permalink":"https://zhulinn.github.io/blog/categories/Network/"}],"tags":[{"name":"面试","slug":"面试","permalink":"https://zhulinn.github.io/blog/tags/面试/"}]},{"title":"Spring基础","slug":"Spring-basic","date":"2018-04-19T00:40:37.000Z","updated":"2018-08-25T04:32:42.786Z","comments":true,"path":"/Spring-basic","link":"","permalink":"https://zhulinn.github.io/blog/Spring-basic","excerpt":"Dependency InjectionSpring offers a container, often referrd to as the Spring application context, that creates and manages application components. These components, or beans, are wired together inside of the Spring application context to make a complete application.The act of wiring beans together is based on a pattern known as dependency injection.","text":"Dependency InjectionSpring offers a container, often referrd to as the Spring application context, that creates and manages application components. These components, or beans, are wired together inside of the Spring application context to make a complete application.The act of wiring beans together is based on a pattern known as dependency injection. IoC stands for “Inversion of Control”.It will act as manager.IoC container creates HelloWorldService object and then pass the object HelloWorld into HelloWorldService through setter. The IoC container is doing is “dependency injection“ into HelloWorldService. The dependence here means that the dependence between objects: HelloWorldService and HelloWorld.So, what is IoC? In case that an object is created from a class traditionally, its fields have value assigned inside the class. Reversely, for Spring, its objects and fields have value injected from the outside by an object called as IoC. IoC Container is a container containing all Spring BEANs used in the application. Spring BeanAny object initialized through Spring container. Bean Scopes singleton - Only one instance of the bean. prototype - A new instance will be created every time the bean is requested. request - Same as prototype, used for web applications. For each HTTP request. session - For each HTTP session. @Scope(ConfigurableBeanFactory.SCOPE_PROTOTYPE) or @Scope(&quot;prototype&quot;)&lt;bean scope=&quot;prototype&quot;&gt;注意session的bean注入singleton的bean时，例如购物车与商店，需要注入作用域代理对象。@Scope(proxyMode=ScopedProxyMode.INTERFACES)，ScopedProxyMode.INTERFACES创建基于接口的代理，ScopedProxyMode.TARGET_CLASS生成基于类的代理。 Bean Configuration1.XML Based Configuration 12345678910111213&lt;beans&gt; &lt;context:component-scan base-package=\"com.journaldev.spring\" /&gt; &lt;bean id=\"innerBean\" class=\"beans.InnerBean \" scope=\"singleton\" /&gt; &lt;bean id=\"outBean\" class=\"beans.OutBean\"&gt; &lt;constructor-arg ref=\"innerBean\"&gt; &lt;constructor-arg value=\"literal text\"&gt; &lt;property name=\"name\" value=\"Jack\"&gt; &lt;/bean&gt; &lt;/beans&gt; Annotation Based Configuration - @Service or @Component, @Scope + @ComponentScan隐式的bean发现机制和自动装配 组件扫描(component scanning) @ComponentScan or &lt;context:component-scand&gt; 自动装配(autowiring) @Autowired Automatic configuration has its roots in a Spring technique known as auto-wiring and another technique known as component-scanning. 1234567891011121314151617package com.journaldev.spring.beans;@Service@Scope(WebApplicationContext.SCOPE_REQUEST)public class MyAnnotatedBean &#123; private int empId; public int getEmpId() &#123; return empId; &#125; public void setEmpId(int empId) &#123; this.empId = empId; &#125; &#125; 123456789@Controller@Scope(\"request\")public class HomeController &#123; @Autowired public void setMyAnnotatedBean(MyAnnotatedBean obj) &#123; this.myAnnotatedBean = obj; &#125; &#125; Java Based Configuration - @Configuration, @Bean 12345678910package com.journaldev.spring.main;import java.util.Date;public class MyService &#123; public void log(String msg)&#123; System.out.println(new Date()+\"::\"+msg); &#125;&#125; 1234567891011121314package com.journaldev.spring.main;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.ComponentScan;import org.springframework.context.annotation.Configuration;@Configurationpublic class MyConfiguration &#123; @Bean public MyService getService()&#123; return new MyService(); &#125;&#125; The @Configuration annotation indicates to Spring that this class is a configuration class which will provide beans to the Spring application context. JavaConfig引用配置导入JavaConfig：@Import(Config.class)导入XML配置：@ImportResource(&quot;classpath:config.xml&quot;) XML引用配置导入JavaConfig(以bean的形式)：&lt;bean class=&quot;package.Config&quot;&gt;导入XML配置：&lt;import resource=&quot;config.xml&quot; /&gt; Advanced Bean ConfigurationProfiles配置profile bean @Profiles(&quot;dev&quot;) &lt;beans profile=&quot;dev&quot;&gt; ，&lt;beans&gt;元素可嵌套 激活profile设置spring.profiles.active(优先)和spring.profiles.default属性，有以下方式： DispatcherServlet初始化参数 Web上下文参数 环境变量 JVM系统属性 集成测试，@ActiveProfiles(&quot;dev&quot;) @Conditional@Conditional(Condition.class) 123public interface Condition &#123; boolean matches(ConditionContext ctext, AnnotatedTypeMetadata, metadata);&#125; 自动装配歧义性 @Primary or &lt;bean primary=&quot;true&quot;&gt; `@Qualifier(“id”) 运行时值注入@PropertySource和Environment123456789101112@Configuration@PropertySource(\"classpath:app.properties\") //属性源public class Config &#123; @Autowired Environment env; @Bean public BlankDisc disc() &#123; return new BlankDisc(env.getProperty(\"disc.title\")); //属性值 &#125;&#125; 属性占位符${...} 和 JavaConfig 使用@Value(&quot;${...}&quot;)注解。配置属性源PropertySourcesPlaceholderConfigurer bean，或 &lt;context:propertyplaceholder /&gt; SpEL#{...} 使用bean的ID来引用bean； 调用方法和访问对象的属性； 对值进行算术、关系和逻辑运算； 正则表达式匹配； 集合操作。 T(...)表达式视作Java对应类型?. 非null?: &quot;1&quot; null时为1songs.?[ condition] 计算集合中符合condition的子集.^[]第一个匹配项.$[]最后一个匹配项songs.![title] 投影title集合 切面 术语通知Advice切面的工作称为通知Advice，通知定义切面是”什么”以及”何时”使用。5种类型通知： @Before @After @After-returning @After-throwing @Around 连接点Join point连接点是在应用执行过程中能够插入切面的一个点。 切点Poincut切点就定义了切面的”何处”，匹配一个或多个连接点。 切面Aspect切面是通知和切点的结合。通知和切点共同定义了切面的全部内容。@Aspect 引入Introduction引入允许我们向现有的类添加新方法或属性。 织入Weaving织入是把切面应用到目标对象并创建新的代理对象的过程。切面在指定的连接点被织入到目标对象中。按目标对象的不同生命周期进行织入： 编译期 类加载期 运行期：Spring AOP 创建切面启动自动代理： @EnableAspectJAutoProxy or &lt;aop:aspectj-autoproxy&gt; 定义切面12345678910111213141516171819202122232425@Aspectpublic class Audience &#123; @Before(\"execution(* me.zhulin.HomeController.hello(...))\") public void dressup() &#123; // do something &#125; @Poincut(\"execution(* me.zhulin.HomeController.hello(...))\") public void hello() &#123;&#125; //标识 @Before(\"hello()\") public void dressup() &#123; // do something &#125; @Around(\"hello()\") public void talk(ProceedingJoinPoint jp)&#123; // Before jp.proceed(); //After &#125;&#125; 1234567891011121314&lt;aop:config&gt; &lt;aop:aspect ref=\"audience\"&gt; //引用 audience Bean &lt;aop:pointcut id=\"performance\" expression=\"execution(** concert.Performance.perform(..))\"/&gt; //定义切点 &lt;aop:before pointcut-ref=\"performance\" //引用切点 method=\"silenceCellPhones\"/&gt; &lt;aop:before pointcut=\"excution(** concert.Performance.perform(..))\" method=\"silenceCellPhones\"/&gt; &lt;/aop:apsect&gt;&lt;/aop:config&gt; 带参通知args(count)表明传递给hello()方法的int类型参数也会传递到通知中去。参数的名称count也与切点方法签名中的参数相匹配。 123456789101112@Aspectpublic class Counter &#123; private int count = 0; @Poincut(\"execution(* me.zhulin.HomeController.hello(int)) and args(count)\") public void sayHi(int count) &#123;&#125; //标识 @Before(\"sayHi(count)\") public void dressup(int count) &#123; this.count += count; &#125; &#125; 引入新功能12345@Aspectpublic class EncoreableIntroducer &#123; @DeclareParents(value=\"concert.Performance+\", defaultImpl=DefaultEncoreable.class) public static Encoreable encoreable; //将Encoreable接口织入Performance bean中&#125; 1234567&lt;aop:aspect&gt; &lt;aop:declare-parents types-matching=\"concert.Performance+\" //父类 implement-interface=\"concert.Encoreable\" //新增接口 default-impl=\"concert.DefaultEncorable\"/&gt; //全限定实现类名 或 delegate-ref=\"encoreableDelegate\"/&gt; //Bean &lt;/aop:apsect&gt; @DeclareParents value指定哪种类型bean需要引入该接口。+表明所以子类型 defaultImpl属性指定了为引入功能提供实现的类。 @DeclareParents注解所标注的静态属性指明了要引入了接口。 之后，将切面声明为bean。当Spring发现一个bean使用了@Aspect注解时，Spring就会创建一个代理，将调用委托给被代理的bean或被引入的实现。","categories":[{"name":"Java Web","slug":"Java-Web","permalink":"https://zhulinn.github.io/blog/categories/Java-Web/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"https://zhulinn.github.io/blog/tags/Spring/"}]},{"title":"分布式基础知识","slug":"distribute-notes","date":"2018-04-16T03:57:27.000Z","updated":"2018-08-25T04:32:42.783Z","comments":true,"path":"/distribute-notes","link":"","permalink":"https://zhulinn.github.io/blog/distribute-notes","excerpt":"Refefence:Interview-Notebook 负载均衡的算法与实现算法 轮询轮询算法把每个请求轮流发送到每个服务器上。该算法比较适合每个服务器的性能差不多的场景。","text":"Refefence:Interview-Notebook 负载均衡的算法与实现算法 轮询轮询算法把每个请求轮流发送到每个服务器上。该算法比较适合每个服务器的性能差不多的场景。 加权轮询加权轮询是在轮询的基础上，根据服务器的性能差异，为服务器赋予一定的权值。 最少连接最少连接算法就是将请求发送给当前最少连接数的服务器上。 加权最小连接在最小连接的基础上，根据服务器的性能为每台服务器分配权重，根据权重计算出每台服务器能处理的连接数。 随机算法把请求随机发送到服务器上。该算法比较适合服务器性能差不多的场景。 实现 HTTP重定向负载均衡服务器收到 HTTP 请求之后会返回服务器的地址，并将该地址写入 HTTP 重定向响应中返回给浏览器，浏览器收到后需要再次发送请求。 缺点： 用户访问的延迟会增加； 如果负载均衡器宕机，就无法访问该站点。 DNS 重定向使用 DNS 作为负载均衡器，根据负载情况返回不同服务器的 IP 地址。大型网站基本使用了这种方式做为第一级负载均衡手段，然后在内部使用其它方式做第二级负载均衡。 缺点： DNS 查找表可能会被客户端缓存起来，那么之后的所有请求都会被重定向到同一个服务器。 修改 MAC 地址使用 LVS（Linux Virtual Server）这种链路层负载均衡器，根据负载情况修改请求的 MAC 地址。 修改 IP 地址在网络层修改请求的目的 IP 地址。 分布式锁Java 提供了两种内置的锁的实现，一种是由 JVM 实现的 synchronized 和 JDK 提供的 Lock，当你的应用是单机或者说单进程应用时，可以使用 synchronized 或 Lock 来实现锁。当应用涉及到多机、多进程共同完成时，那么这时候就需要一个全局锁来实现多个进程之间的同步。 实现 数据库分布式锁 Redis分布式锁 分布式Session Sticky Sessions需要配置负载均衡器，使得一个用户的所有请求都路由到一个服务器节点上，这样就可以把用户的 Session 存放在该服务器节点中。缺点：当服务器节点宕机时，将丢失该服务器节点上的所有 Session。 Session Replication在服务器节点之间进行 Session 同步操作，这样的话用户可以访问任何一个服务器节点。缺点：需要更好的服务器硬件条件；需要对服务器进行配置。 Persistent DataStore将 Session 信息持久化到一个数据库中。缺点：有可能需要去实现存取 Session 的代码。 In-Memory DataStore可以使用 Redis 和 Memcached 这种内存型数据库对 Session 进行存储，可以大大提高 Session 的读写效率。内存型数据库同样可以持久化数据到磁盘中来保证数据的安全性。 CDN架构","categories":[{"name":"分布式","slug":"分布式","permalink":"https://zhulinn.github.io/blog/categories/分布式/"}],"tags":[{"name":"面试","slug":"面试","permalink":"https://zhulinn.github.io/blog/tags/面试/"}]},{"title":"A Shopping Store with Spring Boot, Hibernate, Freemarker & Bootstrap","slug":"Shopping-Store","date":"2018-03-15T14:12:58.000Z","updated":"2018-08-25T04:32:42.781Z","comments":true,"path":"/Shopping-Store","link":"","permalink":"https://zhulinn.github.io/blog/Shopping-Store","excerpt":"Demo: E-ShopGithub: Online Shop Store","text":"Demo: E-ShopGithub: Online Shop Store BeforeRencently, I am developing a online shopping web application with Spring Boot as a practice of Spring. This project is totally developed by myself. Technology stacks includes Spring Boot, Spring Security, Spring Data JPA &amp; Hibernate for the back end and Freemarker, Bootstrap &amp; JavaScript for the front end. It’s a full stack project. IntroductionIn short, this web application is design for both customers and employees. There are total three roles for different users that are ROLE_CUSTOEMR, ROLE_EMPLOYEEE and ROLE_MANAGER. CUSTOMER: Customers can shop on this website and add items to their own shopping cart. Customers can edit items in the cart. The order was created once the customer checkout items. Customers can cancel their own orders before the order is finished.p.s. Right now, the payment functionality is not included. Employee Employees hava the access to view the orders of all the customers. And do some actions on the orders, such as cancel, finish. Employees can edit the product information. Manager Managers have all the functionality of employees. They can also provide new products for sale. TODO","categories":[{"name":"Java Web","slug":"Java-Web","permalink":"https://zhulinn.github.io/blog/categories/Java-Web/"}],"tags":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"https://zhulinn.github.io/blog/tags/Spring-Boot/"},{"name":"Projects","slug":"Projects","permalink":"https://zhulinn.github.io/blog/tags/Projects/"}]},{"title":"Java面试题总结","slug":"Java-Interview","date":"2018-03-05T05:37:48.000Z","updated":"2018-08-25T04:32:42.778Z","comments":true,"path":"/Java-Interview","link":"","permalink":"https://zhulinn.github.io/blog/Java-Interview","excerpt":"面向对象面向对象的本质就是将现实世界描绘成一系列完全自治、封闭的对象。 抽象：抽象是将一类对象的共同特征总结出来构造类的过程，包括数据抽象和行为抽象两方面。抽象只关注对象有哪些属性和行为，并不关注这些行为的细节是什么。 继承：继承是从已有类得到继承信息创建新类的过程。","text":"面向对象面向对象的本质就是将现实世界描绘成一系列完全自治、封闭的对象。 抽象：抽象是将一类对象的共同特征总结出来构造类的过程，包括数据抽象和行为抽象两方面。抽象只关注对象有哪些属性和行为，并不关注这些行为的细节是什么。 继承：继承是从已有类得到继承信息创建新类的过程。 封装：封装是把数据和操作数据的方法绑定起来，对数据的访问只能通过已定义的接口。我们在类中编写的方法就是对实现细节的一种封装；我们编写一个类就是对数据和数据操作的封装。封装就是隐藏一切可隐藏的东西，只向外界提供最简单的编程接口。 多态性：对外一个接口，内部多种实现。用同样的对象引用调用同样的方法但是做了不同的事情。多态性分为编译时的多态性和运行时的多态性。方法重载（overload）实现的是编译时的多态性（也称为前绑定），而方法重写（override）实现的是运行时的多态性（也称为后绑定）。 线程 概念线程是操作系统能够进行运算调度的最小单位，它被包含在进程之中，是进程中的实际运作单位。 线程 vs 进程一进程，多个线程。不同的进程使用不同的内存空间，而所有的线程共享一片相同的内存空间。 实现调用Runable接口重写run()或者继承Thread类。 Thread类中start()和run()区别start()启动新创建的线程，内部调用run()方法。run()在原来的线程中调用。 Runnable和CallableCallable的call()方法可以返回值和抛出异常，返回装载有计算结果的Future对象。 CountDownLatch允许一个或多个线程等待其他线程完成操作。无法重用。 12345678910111213141516171819private static CountDownLatch countDownLatch = new CountDownLatch(2); // wait for N threads finishedpublic void run() throws InterruptedException &#123; Thread thread1 = new Thread(new Runable() &#123; @Override public void run() &#123; countDownLatch.countDown(); //countDown() &#125; &#125;); Thread thread2 = new Thread(new Runable() &#123; @Override public void run() &#123; countDownLatch.countDown(); //countDown() &#125; &#125;); threadstart(); threadstart(); countDownLatch.await(); // 主线程阻塞 等待其他线程，直到N减为0&#125; CyclicBarrier多线程互相等待，到达同一同步点后再一起运行，在其中任意一个线程未达到同步点，其他到达的线程均会被阻塞。通过reset，实现重用。 1234567891011121314151617181920212223242526// 创建拦截线程数为4，当所有线程都达到barrier后执行`this`的run方法private CyclicBarrier cyclicBarrier = new CyclicBarrier(4, this); // 4线程池private Executor executor = Executors.newFixedThreadPool(4);// this 当前类 run方法@Overridepublic void run() &#123;&#125;// 启动4线程 等所有4个线程都达到awaitpublic void calculate() &#123; for(int i = 0; i &lt; 4; i++) &#123; executor.execute(new Runnable() &#123; @Override public void run() &#123; /** Do some staff**/ cyclicBarrier.await(); // 通知达到Barrier &#125; &#125;) &#125;&#125; 原子性简单的读取、赋值(数字直接赋值)才是原子操作。变量之间赋值含有读取变量的操作。getAndIncrement()123456//原子性x = 1;//非原子性y = x;x++;x= x + 1; volatile成员变量使用。保证可见性。一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。保证写操作发生在后续读操作之前，不能保证原子性，如c++；。修改值会立即被更新到主存，读取时，访问内存。普通会放在高速缓存。 Hashtable不允许null。对所有方法synchronized。 ConcurrentHashMap JDK5使用segment分段锁。当一个线程占用一把锁（segment）访问其中一段数据的时候，其他段的数据也能被其它的线程访问，默认分配16个segment。默认比Hashtable效率提高16倍。 JDK8采用CAS和synchronized来保证并发安全。数据结构跟HashMap8的结构一样，数组+链表/红黑二叉树。synchronized只锁定当前链表或红黑二叉树的首节点，这样只要hash不冲突，就不会产生并发，效率又提升N倍 Object的wait() 和 sleep()，Condition接口的await()和signal（）前者对应synchronized锁，后者对应ReentrantLock(Lock接口)锁wait()等待条件为真且其它线程被唤醒时它会释放锁，sleep()方法仅仅释放CPU资源但不会释放锁。wait can be “woken up” by another thread calling notify whereas a sleep cannot. wait and notify must happen in synchronized block. 反射在运行状态中，对于任意的一个类，都能够知道这个类的所有属性和方法，对任意一个对象都能够通过反射机制调用一个类的任意方法，这种动态获取类信息及动态调用类对象方法的功能称为java的反射机制。作用： 动态地创建类的实例，将类绑定到现有的对象中，或从现有的对象中获取类型。 应用程序需要在运行时从某个特定的程序集中载入一个特定的类。 同步/异步和阻塞/非阻塞 同步和异步针对应用程序和内核的交互而言，委托OS处理，完成后通知 阻阻塞和非阻塞是针对于进程在访问数据的时候，根据IO操作的就绪状态来采取的不同方式，阻塞方式下读取或者写入函数将一直等待，而非阻塞方式下，读取或者写入函数会立即返回一个状态值。 IO和NIO IO阻塞式，读取数据，程序等待直至读完。Stream Oriented. Read one or more bytes at a time and cannot move forth and back in the data in a stream. 1234567//IOInputStream input = ... ; // get the InputStream from the client socketBufferedReader reader = new BufferedReader(new InputStreamReader(input));String nameLine = reader.readLine();String ageLine = reader.readLine(); NIO非阻塞式，读取数据，程序继续向下执行。读完数据后通知当前程序（回调）。Buffer Oriented. Move forth and back in the buffer as you need to. Need to check if the buffer contains all the data you need and do not overwrite data in the buffer you have not yet processed. Selectors allows a single thread to monitor multiple channels of input. 12345678//NIOByteBuffer buffer = ByteBuffer.allocate(48);int bytesRead = inChannel.read(buffer);while(! bufferFull(bytesRead) ) &#123; bytesRead = inChannel.read(buffer);&#125; 同步阻塞IO（JAVA BIO）： 同步并阻塞，服务器实现模式为一个连接一个线程，即客户端有连接请求时服务器端就需要启动一个线程进行处理，如果这个连接不做任何事情会造成不必要的线程开销，当然可以通过线程池机制改善。 同步非阻塞IO(Java NIO) ： 同步非阻塞，服务器实现模式为一个请求一个线程，即客户端发送的连接请求都会注册到多路复用器上，多路复用器轮询到连接有I/O请求时才启动一个线程进行处理。用户进程也需要时不时的询问IO操作是否就绪，这就要求用户进程不停的去询问。 异步阻塞IO（Java NIO）： 此种方式下是指应用发起一个IO操作以后，不等待内核IO操作的完成，等内核完成IO操作以后会通知应用程序，这其实就是同步和异步最关键的区别，同步必须等待或者主动的去询问IO是否完成，那么为什么说是阻塞的呢？因为此时是通过select系统调用来完成的，而select函数本身的实现方式是阻塞的，而采用select函数有个好处就是它可以同时监听多个文件句柄（如果从UNP的角度看，select属于同步操作。因为select之后，进程还需要读写数据），从而提高系统的并发性！ 异步非阻塞IO: 在此种模式下，用户进程只需要发起一个IO操作然后立即返回，等IO操作真正的完成以后，应用程序会得到IO操作完成的通知，此时用户进程只需要对数据进行处理就好了，不需要进行实际的IO读写操作，因为真正的IO读取或者写入操作已经由内核完成了。 BIO方式适用于连接数目比较小且固定的架构，这种方式对服务器资源要求比较高，并发局限于应用中，JDK1.4以前的唯一选择，但程序直观简单易理解。 NIO方式适用于连接数目多且连接比较短（轻操作）的架构，比如聊天服务器，并发局限于应用中，编程比较复杂，JDK1.4开始支持。 AIO方式使用于连接数目多且连接比较长（重操作）的架构，比如相册服务器，充分调用OS参与并发操作，编程比较复杂，JDK7开始支持。 JVM内存模型Java运行时(Java runtime)内存模型。五大区：方法区、堆区、虚拟机栈、本地方法栈、程序计数器。程序计数器：线程私有，保存当前线程执行的虚拟机字节码指令的内存地址。多线程切换后，恢复原先状态，找到原先执行的指令。虚拟机栈：线程私有，包含多个栈帧，存储方法数据和部分过程结果的数据结构。方法的调用到返回结果，对应一个栈帧的入栈到出栈。本地方法栈：同虚拟机栈，适用于Native方法。方法区：存储类结构信息的地方，包括常量池，静态变量，构造函数等，类型信息由类加载器在加载时从类文件提取出来。线程共享。存在垃圾收集。堆：存储java实例或对象的地方，GC的主要区域。线程共享 内存中Stack，Heap和Static area用法 栈Stack：基本数据类型变量，对象的引用，函数调用的现场保存 堆Heap：通过new、构造器创建的对象 静态区Static Area：常量， 字面量(literal)，如100，“hello” 类加载器系统会通过加载、连接（验证-准备(初始值)-解析(符号引用=&gt;内存地址的直接引用)）、初始化三个过程来对该类进行初始化。使用一个类之前，JVM需要先将该类的字节码文件（.class文件）从磁盘、网络或其他来源加载到内存中，并对字节码进行解析生成对应的Class对象。)双亲委托机制：优先最上层parent加载器加载。解决类加载的统一性问题，保证了基类都由相同的类加载器加载。 StringBuffer vs StringBuilder都是mutable。StringBuffer的所有方法synchronized，StringBuilder非线程安全。 线程间通信 同步：通过synchronized while轮询 Object#wait/notify机制 管道通信 CopyOnWriteArrayList读不加锁，写加锁。读写分离，写操作通过创捷底层新副本。适用于读多写少。缺点：占内存；无法保证实时性。 synchronized, Lock, ReentrantLocksynchronized: 只有执行结束或异常自动释放锁。Lock接口: 手动释放锁。必须try{}catch{}。可设定等待时间。可在等待时，响应interrupt方法ReentrantLock: 实现Lock接口。 可重入锁可重入锁：synchronized方法内的synchronized方法不必重新申请锁。公平锁：尽量以请求锁的顺序来获取锁。new ReentrantLock(true);ReentrantLock可设置为公平锁(默认非公平).非公平锁：无法保证锁的获取是按照请求锁的顺序进行的，可能导致某些线程永远得不到锁。如sychroniczed TCP三次握手第一次：请求建立连接，等待服务器确认。第二次：服务器发送确认。第三次：客户端确认，开始发送数据。前两次确保接收方能够听懂发送方的话，并做出正确应答。第三次防止接收方一直等待。 TCP四次分手第一次：主机1发送，表示没有数据要发送了。第二次：主机2告诉主机1，同意关闭请求。第三次：主机2请求关闭连接。第四次：主机1发送ACK，主机2关闭，主机1没有收到回复则关闭连接。 Socket连接协议，本地IP，本地端口，远地IP,远地端口。为了区分不同应用程序访问同一TCP端口，使用Socket接口，实现数据传输并发服务。分为三个步骤：服务器监听，客户端请求，连接确认。 OSI七层模型 Semaphore内部维护一组虚拟许可，数量由构造函数的参数指定。访问前，使用acquire获得许可，若许可数量为0，阻塞；访问后使用release释放许可。公平性通过检查阻塞队列实现 AQS抽象类AbstractQueuedSynchronizer队列同步器。state &gt; 0 获取锁，state = 0 释放锁。通过FIFO同步队列完成资源获取线程的排队工作。所有的锁机制都可以基于同步器定制来实现的。 ReentrantReadWriter一个读锁（共享锁），一个写锁（独占锁）。允许多个读线程访问。适用于读多写少 ExecutorExecutor接口是Executor框架最基础的部分，定义用于执行Runnable的execute方法。ExecutorService接口继承Executor接口，execute()执行Runnable任务，submit()执行Callable或Runnable任务，并返回Future结果。Future接口：判断任务是否完成；中断任务；获取执行结果。 垃圾收集算法： 引用计数法(Reference Counting)无法处理循环引用：A-&gt;B,B-&gt;A。Java没有 标记-清除算法 (Mark-Sweep)未标记对象为垃圾对象，清除所有未被标记的对象。问题：存在大量空间碎片。 复制算法 (Copying)内存空间分为两块，每次只是用一块，垃圾回收时，复制存活对象到另一块，清除所有。问题：内存折半。 标记-压缩算法 (Mark-Compact)标记，压缩再清理。 增量算法 (Incremental Collecting)解决垃圾回收长时间的线程阻塞，让垃圾收集线程和应用程序线程交替执行。问题：线程切换和上下文转换的消耗。 分代 (Generational Collecting)年轻代：复制算法；老生代：标记-压缩算法 类型：串行/并行 ，按线程数分并发式/独占式，按工作模式分，并发交替工作压缩式/非压缩式新生代/老年代 分类新生： Serial新生代串行收集器：独占式。复制算法，没有线程切换开销，适合单CPU,小内存。 ParNew并行收集器：独占式。复制算法，新生代的并行收集器。适合并行CPU Parallel Scavenge新生代回收收集器：相比并行收集器，注重吞吐量，自适应调节老生: Serial Old老年代串行收集器：独占式。标记-压缩算法 Parallel Old老年代并行回收收集器：关注吞吐量 CMS收集器：并发式Concurrent Mark Sweep，标记-清除算法。关注于系统停顿时间 G1收集器：服务器的，标记-压缩算法","categories":[{"name":"Java SE","slug":"Java-SE","permalink":"https://zhulinn.github.io/blog/categories/Java-SE/"}],"tags":[{"name":"面试","slug":"面试","permalink":"https://zhulinn.github.io/blog/tags/面试/"}]},{"title":"JVM知识点","slug":"JVM-Summary","date":"2018-03-03T03:42:14.000Z","updated":"2018-08-25T04:32:42.774Z","comments":true,"path":"/JVM-Summary","link":"","permalink":"https://zhulinn.github.io/blog/JVM-Summary","excerpt":"Reference: 纯洁的微笑 类的加载类加载的定义将类的.class文件中的二进制数据读入到内存中，将其放在运行时数据取的方法区内，然后在堆区创建java.lang.Class对象，封装方法区内的数据结构。Class对象封装方法区的数据结构，提供访问方法区的数据结构的接口。","text":"Reference: 纯洁的微笑 类的加载类加载的定义将类的.class文件中的二进制数据读入到内存中，将其放在运行时数据取的方法区内，然后在堆区创建java.lang.Class对象，封装方法区内的数据结构。Class对象封装方法区的数据结构，提供访问方法区的数据结构的接口。 类加载的过程 加载，查找并加载类的二进制数据，在Java堆中也创建一个java.lang.Class类的对象 连接，连接又包含三块内容：验证、准备、初始化。 验证，文件格式、元数据、字节码、符号引用验证； 准备，为类的静态变量分配内存，并将其初始化为默认值； 解析，把类中的符号引用转换为直接引用（内存地址） 初始化，为类的静态变量赋予正确的初始值 使用，new出对象程序中使用 卸载，执行垃圾回收 类加载器 加载机制 全盘负责，当一个类加载器负责加载某个Class时，该Class所依赖的和引用的其他Class也将由该类加载器负责载入，除非显示使用另外一个类加载器来载入 父类委托，先让父类加载器试图加载该类，只有在父类加载器无法加载该类时才尝试从自己的类路径中加载该类。解决类加载的统一性问题，保证了基类都由相同的类加载器加载。 缓存机制，缓存机制将会保证所有加载过的Class都会被缓存，当程序中需要使用某个Class时，类加载器先从缓存区寻找该Class，只有缓存区不存在，系统才会读取该类对应的二进制数据，并将其转换成Class对象，存入缓存区。这就是为什么修改了Class后，必须重启JVM，程序的修改才会生效 对象分配规则 对象优先分配在Eden区，如果Eden区没有足够的空间时，虚拟机执行一次Minor GC。 大对象直接进入老年代（大对象是指需要大量连续内存空间的对象）。这样做的目的是避免在Eden区和两个Survivor区之间发生大量的内存拷贝（新生代采用复制算法收集内存）。 长期存活的对象进入老年代。虚拟机为每个对象定义了一个年龄计数器，如果对象经过了1次Minor GC那么对象会进入Survivor区，之后每经过一次Minor GC那么对象的年龄加1，知道达到阀值对象进入老年区。 动态判断对象的年龄。如果Survivor区中相同年龄的所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象可以直接进入老年代。 空间分配担保。每次进行Minor GC时，JVM会计算Survivor区移至老年区的对象的平均大小，如果这个值大于老年区的剩余值大小则进行一次Full GC，如果小于检查HandlePromotionFailure设置，如果true则只进行Monitor GC,如果false则进行Full GC。 JVM内存模型Java运行时(Java runtime)内存模型。五大区：方法区、堆区、虚拟机栈、本地方法栈、程序计数器。程序计数器：线程私有，保存当前线程执行的虚拟机字节码指令的内存地址。多线程切换后，恢复原先状态，找到原先执行的指令。虚拟机栈：线程私有，包含多个栈帧，存储方法数据和部分过程结果的数据结构。方法的调用到返回结果，对应一个栈帧的入栈到出栈。本地方法栈：同虚拟机栈，适用于Native方法。方法区：存储类结构信息的地方，包括常量池，静态变量，构造函数等，类型信息由类加载器在加载时从类文件提取出来。堆：存储java实例或对象的地方，GC的主要区域。堆内存是JVM中最大的一块由年轻代和老年代组成，而年轻代内存又被分成三部分，Eden空间、From Survivor空间、To Survivor空间。 GC算法存活判断 引用计数：无法解决对象相互循环引用 可达性分析：从GC Roots向下搜索，搜索所走过的路径称为引用链。当一个对象到GC Roots没有任何引用链相连时，则证明此对象是不可用的，不可达对象。 算法 引用计数法(Reference Counting)无法处理循环引用：A-&gt;B,B-&gt;A。Java没有 标记-清除算法 (Mark-Sweep)未标记对象为垃圾对象，清除所有未被标记的对象。问题：存在大量空间碎片。 复制算法 (Copying)内存空间分为两块，每次只是用一块，垃圾回收时，复制存活对象到另一块，清除所有。问题：内存折半。 标记-压缩算法 (Mark-Compact)标记，压缩再清理。 增量算法 (Incremental Collecting)解决垃圾回收长时间的线程阻塞，让垃圾收集线程和应用程序线程交替执行。问题：线程切换和上下文转换的消耗。 分代 (Generational Collecting)年轻代：复制算法；老生代：标记-压缩算法 类型串行/并行 ，按线程数分并发式/独占式，按工作模式分，并发交替工作压缩式/非压缩式新生代/老年代 分类新生： Serial新生代串行收集器：独占式。复制算法，没有线程切换开销，适合单CPU,小内存。 ParNew并行收集器：Serial多线程版，适合并行CPU Parallel Scavenge新生代回收收集器：相比并行收集器，注重吞吐量，自适应调节老生: Serial Old老年代串行收集器：独占式。标记-压缩算法 Parallel Old老年代并行回收收集器：多线程版，关注吞吐量 CMS收集器：并发式Concurrent Mark Sweep，标记-清除算法。关注于系统停顿时间 G1收集器：服务器的，标记-压缩算法","categories":[{"name":"Java SE","slug":"Java-SE","permalink":"https://zhulinn.github.io/blog/categories/Java-SE/"}],"tags":[{"name":"JVM","slug":"JVM","permalink":"https://zhulinn.github.io/blog/tags/JVM/"}]},{"title":"JavaEE JSP Notes","slug":"JavaEE-JSP-Notes","date":"2018-02-10T00:26:24.000Z","updated":"2018-08-25T04:32:42.772Z","comments":true,"path":"/JavaEE-JSP-Notes","link":"","permalink":"https://zhulinn.github.io/blog/JavaEE-JSP-Notes","excerpt":"Life cycle of JSP Page Translatione.g. home.jsp -&gt; home_jsp.java Compilation","text":"Life cycle of JSP Page Translatione.g. home.jsp -&gt; home_jsp.java Compilation e.g. home_jsp.java -&gt; home_jsp.class Class Loading Instance Creation Initialization Request Processing Destroy JSP Implicit Object out ObjectOutput content to be sent in client response. out.print() is same as &lt;%= %&gt; request Object response Object config ObjectGet the JSP init params. application ObjectGet the context information and attributes in JSP. getRequestDispatcher(&quot;XXX&quot;) session ObjectWhenever we request a JSP page, container automatically creates a session for the JSP. &lt;%@ page session=&quot;false&quot;%&gt; pageContext ObjectWe can use pageContext to get and set attributes with different scopes and to forward request to other resources. pageContext object also hold reference to other implicit object. page ObjectRepresents the current JSP page. Provide reference to the generated servlet class. exception ObjectError pages. JSP Directives page directivee.g. &lt;%@ page import=&quot;java.util.Date,java.util.List,java.io.*&quot; %&gt; include directivee.g. &lt;%@ include file=&quot;test.html&quot; %&gt; taglib directivee.g. &lt;%@ taglib uri=&quot;/WEB-INF/c.tld&quot; prefix=&quot;c&quot;%&gt; Exception Handling in JSPDefine an Error PageTo handle exceptions thrown by the JSP page, all we need is an error page and set page directive attribute isErrorPage value to true. ConfigurationTwo ways Set page directive errorPage attribute. &lt;%@ page errorPage=&quot;error.jsp&quot;%&gt; Define error page in web.xml with error-page1234 &lt;error-page&gt;&lt;error-code&gt;404&lt;/error-code&gt;&lt;location&gt;/error.jsp&lt;/location&gt;&lt;/error-page&gt; Expression Language(EL)We can disable EL expression in JSP by setting isELIgnored to true. EL Implicati Objectse.g. pageScope, requestScope, sessionScope, applicationScope, param, paramValues, header, headerValues, cookie, initParam – Map typepageContext – pageContext type If scope is not provided, the JSP EL looks into page, request, session and application scope to find the named attribute. EL Operators Dot or Access Operator .${firstObj.secondObj} Collection Operator []${requestScope[“foo.bar”]}${myList[1]} and ${myList[“1”]}${myMap[expr]} Arithmetic Operator+, -, *, /, % Logical Operators&amp;&amp;, ||, ! Relational Operators==, !=, &lt;, &gt;, &lt;=, &gt;= Action Tagsjsp:useBeanUse or create one if it’s null1&lt;jsp:useBean id=\"myBeanAttribute\" class=\"com.journaldev.MyBean\" scope=\"request\" /&gt; JSP container will first try to find the myBeanAttribute attribute in the request scope but if it’s not existing then it will create the instance of MyBean and then assign it to the myBeanAttribute id variable in JSP and sets it as an attribute to the request scope. getProperty is limittedWe can get it’s properties using jsp:getProperty action like below.1&lt;jsp:getProperty name=\"myBeanAttribute\" property=\"count\" /&gt; getProperty is limited because we can’t get the property of a property. For example if MyBean has a property that is another java bean, then we can’t use JSP action tags to get it’s value, for that we have JSP EL. Set only on new one123&lt;jsp:useBean id=\"myBeanAttribute\" class=\"com.journaldev.MyBean\" scope=\"request\"&gt; &lt;jsp:setProperty name=\"myBeanAttribute\" property=\"count\" value=\"5\" /&gt;&lt;/jsp:useBean&gt; jsp:setProperty inside the jsp:useBeanSet only if jsp:useBean is creating a new instance. type and class1&lt;jsp:useBean id=\"person\" type=\"Person\" class=\"Employee\" scope=\"request\" /&gt; If we don’t provide class attribute value, it must has an attribute called person.If we don’t provide scope attribute value, it’s defaulted to page scope. param Set Been properties from request parametersIf we want to set the Java Bean properties from request parameters, we can use param attribute like below.123&lt;jsp:useBean id=\"myBeanAttribute\" class=\"com.journaldev.MyBean\" scope=\"session\"&gt;&lt;jsp:setProperty name=\"myBeanAttribute\" property=\"id\" param=\"empID\" /&gt;&lt;/jsp:useBean&gt; If property and param attribute values are same, we can skip the param attribute.123&lt;jsp:useBean id=\"myBeanAttribute\" class=\"com.journaldev.MyBean\" scope=\"session\"&gt;&lt;jsp:setProperty name=\"myBeanAttribute\" property=\"id\" /&gt;&lt;/jsp:useBean&gt; If all the request parameter names matches with the java bean properties, then we can simply set bean properties like below.123&lt;jsp:useBean id=\"myBeanAttribute\" class=\"com.journaldev.MyBean\" scope=\"session\"&gt;&lt;jsp:setProperty name=\"myBeanAttribute\" property=\"*\" /&gt;&lt;/jsp:useBean&gt; jsp:includeWe can use jsp:include action to include another resource in the JSP page.1&lt;jsp:include page=\"header.jsp\" /&gt; Difference with JSP include directiveIn include directive, the content to other resource is added to the generated servlet code at the time of translation whereas with include action it happens at runtime.We can pass Parameters to the included resource using jsp:param123&lt;jsp:include page=\"header.jsp\"&gt; &lt;jsp:param name=\"myParam\" value=\"myParam value\" /&gt;&lt;/jsp:include&gt; jsp:forwardWe can use jsp:forward to forward the request to another resource to handle it.1&lt;jsp:forward page=\"login.jsp\" /&gt; JSTL tags Core TagsIteration, conditional logic catch exception, url, forward or redirecr response… 123&lt;%@ taglib uri=\"http://java.sun.com/jsp/jstl/core\" prefix=\"c\" %&gt;&lt;%@ taglib uri=\"http://java.sun.com/jsp/jstl/fmt\" prefix=\"fmt\" %&gt; SQL TagsInteraction with relational databases. 1&lt;%@ taglib uri=\"http://java.sun.com/jsp/jstl/sql\" prefix=\"sql\" %&gt; XML TagsWork with XML documents like parsing XML, transforming XML data and XPath expressions evaluation. 1&lt;%@ taglib uri=\"http://java.sun.com/jsp/jstl/xml\" prefix=\"x\" %&gt; Functions TagsPerform common operation, most of them are for string manipulation such as concatenation, split etc. 1&lt;%@ taglib uri=\"http://java.sun.com/jsp/jstl/functions\" prefix=\"fn\" %&gt; Custom Tag Creating cumtom tags handler class Extend javax.servlet.jsp.tagext.SimpleTagSupport Override doTags() method Provide setter methods for the attributes we need for the tag.123456789101112131415161718public class NumberFormatterTag extends SimpleTagSupport &#123; private String format; private String number; //Setters public void setFormat(String format) &#123; this.format = format; &#125; public void setNumber(String number) &#123; this.number = number; &#125; @Override public void doTag() throws JspException, IOException &#123; ... &#125; Creating Custom Tag Library Descriptor(TLD) File inside WEB-INF directory.123456789101112131415&lt;short-name&gt;mytags&lt;/short-name&gt;&lt;uri&gt;https://journaldev.com/jsp/tlds/mytags&lt;/uri&gt;&lt;tag&gt; &lt;name&gt;formatNumber&lt;/name&gt; &lt;tag-class&gt;com.journaldev.jsp.customtags.NumberFormatterTag&lt;/tag-class&gt; &lt;body-content&gt;empty&lt;/body-content&gt; &lt;attribute&gt; &lt;name&gt;format&lt;/name&gt; &lt;required&gt;true&lt;/required&gt; &lt;/attribute&gt; &lt;attribute&gt; &lt;name&gt;number&lt;/name&gt; &lt;required&gt;true&lt;/required&gt; &lt;/attribute&gt;&lt;/tag&gt; Deployment Descriptor Configuration 123456&lt;jsp-config&gt; &lt;taglib&gt; &lt;taglib-uri&gt;https://journaldev.com/jsp/tlds/mytags&lt;/taglib-uri&gt; &lt;taglib-location&gt;/WEB-INF/numberformatter.tld&lt;/taglib-location&gt; &lt;/taglib&gt;&lt;/jsp-config Refefence:JSP EL Tutorial","categories":[{"name":"JavaEE","slug":"JavaEE","permalink":"https://zhulinn.github.io/blog/categories/JavaEE/"}],"tags":[{"name":"JSP","slug":"JSP","permalink":"https://zhulinn.github.io/blog/tags/JSP/"}]},{"title":"JavaEE Servlet Notes","slug":"JavaEE-Servlet-Notes","date":"2018-02-08T16:56:15.000Z","updated":"2018-08-25T04:32:42.768Z","comments":true,"path":"/JavaEE-Servlet-Notes","link":"","permalink":"https://zhulinn.github.io/blog/JavaEE-Servlet-Notes","excerpt":"Web Container Communication Support – Container provides easy way of communication between web server and the servlets and JSPs. Because of container, we don’t need to build a server socket to listen for any request from web server, parse the request and generate response.","text":"Web Container Communication Support – Container provides easy way of communication between web server and the servlets and JSPs. Because of container, we don’t need to build a server socket to listen for any request from web server, parse the request and generate response. All these important and complex tasks are done by container and all we need to focus is on our business logic for our applications. Lifecycle and Resource Management – Container takes care of managing the life cycle of servlet. Container takes care of loading the servlets into memory, initializing servlets, invoking servlet methods and destroying them. Container also provides utility like JNDI for resource pooling and management. Multithreading Support – Container creates new thread for every request to the servlet and when it’s processed the thread dies. So servlets are not initialized for each request and saves time and memory. JSP Support – JSPs doesn’t look like normal java classes and web container provides support for JSP. Every JSP in the application is compiled by container and converted to Servlet and then container manages them like other servlets. Miscellaneous Task – Web container manages the resource pool, does memory optimizations, run garbage collector, provides security configurations, support for multiple applications, hot deployment and several other tasks behind the scene that makes our life easier. The principle when programming Servlet + JSP Never allow users to directly access to your JSP page.Set JSP files in the WEB-INF folder or its subdirectories. JSP is only considered as the place to display interface. Servlet acts as the controller of the application flows and program logical processing. Open the JDBC connection and transaction management in Filter (Optional). Web Application Directory Structure URL SessionSession is a conversional state between client and server and it can consists of multiple request and response between client and server. Since HTTP and Web Server both are stateless, the only way to maintain a session is when some unique information about the session (session id) is passed between server and client in every request and response. MethodsThere are mainly two ways through which we can provide unique identifier in request and response. CookiesCookies are small piece of information that is sent by web server in response header and gets stored in the browser cookies. 1234567891011121314151617181920212223242526// SendCookies loginCookie = new Cookie(\"user\", user);loginCookie.setMaxAge(30*60);response.addCookie(loginCookie);//RecieveCookie[] cookies = request.getCookies();if(cookies != null) &#123; if(cookie.getName().equals(\"user\")) userName = cookie.getValue();&#125;//removeCookie loginCookie = null;Cookie[] cookies = request.getCookies();for(Cookie cookie : cookies)&#123; if(cookie.getName().equals(\"user\"))&#123; loginCookie = cookie; break; &#125; &#125;if(loginCookie != null)&#123; loginCookie.setMaxAge(0); response.addCookie(loginCookie);&#125; URL RewritingWe can append a session identifier parameter with every request and response to keep track of the session. Only when the cookies are disabled. HttpServletResponse encodeURL() encodes URL. HttpServletResponse encodeRedirectURL redicts the request with session information. Servlet 123//Get the encoded URL stringString encodedURL = response.encodeRedirectURL(\"LoginSuccess.jsp\");response.sendRedirect(encodedURL); JSP 12345&lt;!-- need to encode all the URLs where we want session information to be passed --&gt;&lt;a href=\"&lt;%=response.encodeURL(\"CheckoutPage.jsp\") %&gt;\"&gt;Checkout Page&lt;/a&gt;&lt;form action=\"&lt;%=response.encodeURL(\"LogoutServlet\") %&gt;\" method=\"post\"&gt;&lt;input type=\"submit\" value=\"Logout\" &gt;&lt;/form&gt; HttpSessionServlet API provides Session management through HttpSession interface.HttpServletRequest getSession() It returns the session object attached with the request, if the request has no session attached, then it creates a new session and return it. It creates the new HttpSession object and also add a Cookie to the response object with name JSESSIONID and value as session id. If the cookies are disabled at client side and we are using URL rewriting then this method uses the jsessionid value from the request URL to find the corresponding session.123456789HttpSession session = request.getSession();session.setAttribute(\"user\", \"Pankaj\");//setting session to expiry in 30 minssession.setMaxInactiveInterval(30*60);//remove sessionsession.invalidate(); ServletConfiguration web.xml 123456789101112131415&lt;servlet&gt; &lt;display-name&gt;ss&lt;/display-name&gt; &lt;servlet-name&gt;SimpleServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;footmark.servlet.SimpleServlet&lt;/servlet-class&gt; &lt;load-on-startup&gt;-1&lt;/load-on-startup&gt; &lt;async-supported&gt;true&lt;/async-supported&gt; &lt;init-param&gt; &lt;param-name&gt;username&lt;/param-name&gt; &lt;param-value&gt;tom&lt;/param-value&gt; &lt;/init-param&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;SimpleServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/simple&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; Annotation 12345@WebServlet(urlPatterns = &#123;\"/simple\"&#125;, asyncSupported = true, loadOnStartup = -1, name = \"SimpleServlet\", displayName = \"ss\", initParams = &#123;@WebInitParam(name = \"username\", value = \"tom\")&#125; ) public class SimpleServlet extends HttpServlet&#123; … &#125; FilterConfiguration web.xml 12345678&lt;filter&gt; &lt;filter-name&gt;SimpleFilter&lt;/filter-name&gt; &lt;filter-class&gt;xxx&lt;/filter-class&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;SimpleFilter&lt;/filter-name&gt; &lt;servlet-name&gt;SimpleServlet&lt;/servlet-name&gt; &lt;/filter-mapping&gt; Annotation 12@WebFilter(servletNames = &#123;\"SimpleServlet\"&#125;,filterName=\"SimpleFilter\") public class LessThanSixFilter implements Filter&#123;...&#125; Attribute type filterName String value String[] urlPatterns String[] servletNames String[] dispatcherTypes DispatcherType initPatams WebInitParam[] asyncSupported boolean description String displayName String ListenerWhy?We know that using ServletContext, we can create an attribute with application scope that all other servlets can access but we can initialize ServletContext init parameters as String only in deployment descriptor (web.xml). To set an attribute in ServletContext for Database Connection, we can create a Listener for the application startup event to read context init parameters and create a database connection and set it to context attribute for use by other resources. Configuration web.xml 123&lt;listener&gt; &lt;listener-classcom.journaldev.listener.SimpleListener&lt;/listener-class&gt; &lt;/listener&gt; Annotation 12@WebListener(\"This is only a demo listener\") public class SimpleListener implements ServletContextListener&#123;...&#125; Exception and Error HandingBefore servlet container invokes the servlet to handle the exception, it sets some attributes in the request to get useful information about the exception, some of them are javax.servlet.error.exception, javax.servlet.error.status_code, javax.servlet.error.servlet_name and javax.servlet.error.request_uri.You can also use JSP page as exception handler, just provide the location of jsp file rather than servlet mapping.123456789&lt;error-page&gt; &lt;error-code&gt;404&lt;/error-code&gt; &lt;location&gt;AppErrorHandler.jsp&lt;/location&gt;&lt;/error-page&gt;&lt;error-page&gt;&lt;exception-type&gt;javax.servlet.ServletException&lt;/exception-type&gt;&lt;location&gt;/AppExceptionHandler&lt;/location&gt;&lt;/error-page&gt; Servlet 3 File Upload@MultipartConfig Servlet Specs 3.0 provided additional support for uploading files to server. Annotate File Upload handler servlet with MultipartConfig annotation to handle multipart/form-data requests. fileSizeThreshol: The size threshold after which the file will be written to disk. In bytes. location: Default value is “”. maxFileSize: Default value is -1L means unlimited. In bytes. maxRequestSize: Default value is -1L that means unlimited. In bytes. Part InterfacePart interface represents a part or form item that was received within a multipart/form-data POST request. HttpServletRequestNew methods got added in HttpServletRequest to get all the parts in multipart/form-data request through getParts() method. We can get a specific part using getPart(String partName) method. Implement HTMLSubmit the form to send POST request and . enctype of form should be multipart/form-data. Use input element with type as file. FileUploadServlet123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354@WebServlet(\"/FileUploadServlet\")@MultipartConfig(fileSizeThreshold=1024*1024*10, // 10 MB maxFileSize=1024*1024*50, // 50 MB maxRequestSize=1024*1024*100) // 100 MBpublic class FileUploadServlet extends HttpServlet &#123; private static final long serialVersionUID = 205242440643911308L; /** * Directory where uploaded files will be saved, its relative to * the web application directory. */ private static final String UPLOAD_DIR = \"uploads\"; protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; // gets absolute path of the web application String applicationPath = request.getServletContext().getRealPath(\"\"); // constructs path of the directory to save uploaded file String uploadFilePath = applicationPath + File.separator + UPLOAD_DIR; // creates the save directory if it does not exists File fileSaveDir = new File(uploadFilePath); if (!fileSaveDir.exists()) &#123; fileSaveDir.mkdirs(); &#125; String fileName = null; //Get all the parts from request and write it to the file on server for (Part part : request.getParts()) &#123; fileName = getFileName(part); part.write(uploadFilePath + File.separator + fileName); &#125; request.setAttribute(\"message\", fileName + \" File uploaded successfully!\"); getServletContext().getRequestDispatcher(\"/response.jsp\").forward( request, response); &#125; /** * Utility method to get file name from HTTP header content-disposition */ private String getFileName(Part part) &#123; String contentDisp = part.getHeader(\"content-disposition\"); System.out.println(\"content-disposition header= \"+contentDisp); String[] tokens = contentDisp.split(\";\"); for (String token : tokens) &#123; if (token.trim().startsWith(\"filename\")) &#123; return token.substring(token.indexOf(\"=\") + 2, token.length()-1); &#125; &#125; return \"\"; &#125;&#125; JavaBeanA JavaBean is just a standard. All properties private (use getters/setters) A public no-argument constructor Implements Serializable.","categories":[{"name":"JavaEE","slug":"JavaEE","permalink":"https://zhulinn.github.io/blog/categories/JavaEE/"}],"tags":[{"name":"Servlet","slug":"Servlet","permalink":"https://zhulinn.github.io/blog/tags/Servlet/"},{"name":"JSP","slug":"JSP","permalink":"https://zhulinn.github.io/blog/tags/JSP/"}]},{"title":"UEFI+GPT启动Windows原理及手动修复引导","slug":"UEFI-GPT-Boot","date":"2018-01-29T16:08:44.000Z","updated":"2018-08-25T04:32:42.764Z","comments":true,"path":"/UEFI-GPT-Boot","link":"","permalink":"https://zhulinn.github.io/blog/UEFI-GPT-Boot","excerpt":"引导原理接通电源 → 启动bios → esp分区 → /EFI/boot/bootx64.efi →/EFI/Microsoft/BCD → 系统分区 → /Windows/system32/winload.exe 手动修复引导","text":"引导原理接通电源 → 启动bios → esp分区 → /EFI/boot/bootx64.efi →/EFI/Microsoft/BCD → 系统分区 → /Windows/system32/winload.exe 手动修复引导 转换硬盘格式为GPT 新建esp分区 或FAT16类型 esp分区下文件目录123/efi/boot/bootx64.efi/efi/Microsoft/boot/BCD 其中bootx64.efi通过拷贝系统分区:/windows/boot/EFI/bootmgfw.efi 并重命名bootx64.efi BCD 通过PE中bootice软件新建(将启动分区设置为系统分区)","categories":[{"name":"日常","slug":"日常","permalink":"https://zhulinn.github.io/blog/categories/日常/"}],"tags":[{"name":"装机","slug":"装机","permalink":"https://zhulinn.github.io/blog/tags/装机/"}]}]}